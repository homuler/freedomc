module Handler.FC.Typing.MusicRegister where

import Import
import qualified FC.Data.Music as FCDM
import qualified FC.Form.Fields as FCField
import System.FilePath
import System.Directory
import qualified Data.Text as T
import qualified Data.Char as C
import Control.Monad

musicUploadForm :: Html -> MForm Handler (FormResult FCDM.MusicData, Widget)
musicUploadForm extra = do
  (titleRes, titleView) <-
    mreq textField
    (bootstrapFieldSettings "Music Title") Nothing
  (musicianRes, musicianView) <-
    mreq textField
    (bootstrapFieldSettings "Musician Name") Nothing
  (genreRes, genreView) <-
    mopt (FCField.multiCheckBoxList FCDM.genres)
    "Music Genre" Nothing
  (formatRes, formatView) <-
    mreq (radioFieldList FCDM.formats)
    "Music Format" $ Just FCDM.Video
  (musicFileRes, musicFileView) <-
    mreq fileField
--    (bootstrapFieldSettings "Music File") Nothing
    "Music File" Nothing
  (lyricFileRes, lyricFileView) <-
    mreq fileField
    "Lyric File" Nothing
  (configFileRes, configFileView) <-
    mopt fileField
    "Config File" Nothing
  let musicDataRes = FCDM.MusicData <$> titleRes
                                    <*> musicianRes
                                    <*> genreRes
                                    <*> formatRes
                                    <*> musicFileRes
                                    <*> lyricFileRes
                                    <*> configFileRes
      widget = $(widgetFile "fc/fc-music-register-form")
  return (musicDataRes, widget)

getFCMusicRegisterR :: Handler Html
getFCMusicRegisterR = do
  ((_, widget), enctype) <- runFormPost musicUploadForm
  defaultLayout $ do
    setTitle "FC -Music Register-"
    $(widgetFile "fc/fc-music-register")

postFCMusicRegisterR :: Handler Html
postFCMusicRegisterR = do
  ((result, widget), enctype) <- runFormPost musicUploadForm
  case result of
    FormSuccess musicData -> do
      $logInfo $ "post success"
      packageDir <- liftIO $ getDirName $ T.unpack $ FCDM.title musicData
      liftIO $ createMusicDirectory packageDir
      $logInfo $ T.append "directory created" $ T.pack packageDir
      musicFilename <- writeToServer packageDir
                       (FCDM.soundData musicData)
      $logInfo $ T.append (FCDM.title musicData) $ T.pack "'s music data has been saved."
      lyricFilename <- writeToServer packageDir
                       (FCDM.lyricData musicData)
      _ <- case (FCDM.configData musicData) of
           Just configFile -> writeToServer packageDir
                              configFile
           _ -> return ""
      $logInfo $ T.append (FCDM.title musicData) $ T.pack "'s lyric data has been saved."
      setMessage "Music Data saved"
      setSession "mTitle" $ FCDM.title musicData
      setSession "mMusician" $ FCDM.musician musicData
      setSession "mGenre" $ (T.pack . show) $ FCDM.genre musicData
      case FCDM.format musicData of
        FCDM.Video -> setSession "mFormat" "Video"
        FCDM.Sound -> setSession "mFormat" "Sound"
      setSession "mSoundSrc" $ T.pack $ "/" ++ musicFilename
      setSession "mLyricSrc" $ T.pack lyricFilename
      setSession "mConfigSrc" $ (T.pack . show) $ fileName
        <$> FCDM.configData musicData
      redirect $ FCMusicEditorR $ FCDM.title musicData
    _ -> do
      setMessage "Music Data Saving Process Failed"
      redirect FCMusicRegisterR

uploadDirectory :: FilePath
uploadDirectory = "static"

musicRootDirectory :: FilePath
musicRootDirectory = uploadDirectory </> "music"

createMusicDirectory :: FilePath -> IO ()
createMusicDirectory dir = do
  let musicDir = musicRootDirectory </> dir
  existDir <- doesDirectoryExist musicDir
  unless existDir$
    createDirectory musicDir

writeToServer :: String -> FileInfo -> Handler FilePath
writeToServer path file = do
  let filename = T.unpack $ fileName file
      filepath = musicFilePath path filename
  liftIO $ fileMove file filepath
  return filepath

musicFilePath :: String -> String -> FilePath
musicFilePath subdir file  = musicRootDirectory </> subdir </> file

getDirName :: String -> IO FilePath
getDirName str = do
  isNotUnique <- doesDirectoryExist $ musicRootDirectory </> tmp
  if isNotUnique
    then getNextDir tmp 2
    else return tmp
    where tmp = let (x:xs) = map (map C.toLower) $ Import.words str
                in concat $ x:map capitalize xs
          getNextDir :: String -> Int -> IO FilePath
          getNextDir dir n = do
            doesExist <- doesDirectoryExist $
                         musicRootDirectory </> (dir ++ show n)
            if not doesExist
              then return (dir ++ show n)
              else getNextDir dir (n+1)

capitalize :: String -> String
capitalize (x:xs) = C.toUpper x:xs
capitalize x = x
